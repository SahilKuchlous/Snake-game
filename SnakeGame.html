<head>
	<title>Snake!</title>
</head>

<body>

	<canvas id = "canvas" width = "400" height = "400"></canvas>

	<script src = "http://code.jquery.com/jquery-1.11.3.min.js"></script>

	<script>

		// Set up canvas
		var canvas = document.getElementById("canvas");
		var cxt = canvas.getContext("2d");

		// Get the width and height of the canvas
		var width = canvas.width;
		var height = canvas.height;

		// Work out the width and height in blocks
		var blockSize = 10;
		var widthInBlocks = width / blockSize;
		var heightInBlocks = height / blockSize;

		// Set score to 0
		var score = 0;

		// Draw the border	
		var drawBorder = function () {
			cxt.fillStyle = "Gray";
			cxt.fillRect(0, 0, width, blockSize);
			cxt.fillRect(0, height - blockSize, width, blockSize);
			cxt.fillRect(0, 0, blockSize, height);
			cxt.fillRect(width - blockSize, 0, blockSize, height);
		};

		// Draw the score in the top-left corner
		var drawScore = function () {
			cxt.font = "20px Courier";
			cxt.fillStyle = "Black";
			cxt.textAlign = "left";
			cxt.textBaseline = "top";
			cxt.fillText("Score: " + score, blockSize, blockSize);
		};

		// Clear the interval and display the game over text
		var gameOver = function () {
			clearInterval(intervalId);
			cxt.font = "60px Courier";
			cxt.fillStyle = "Black";
			cxt.textAlign = "center"
			cxt.textBaseline = "middle";
			cxt.fillText("Game Over", width / 2, height / 2);
		};

		// Draw a circle
		var circle  = function (x, y, radius, fillCircle) {
			cxt.beginPath();
			cxt.arc(x, y, radius, 0, Math.PI * 2, false);
			if (fillCircle) {
				cxt.fill();
			} else {
				cxt.stroke();
			};
		};

		// The Block constructor
		var Block = function (col, row) {
			this.col = col;
			this.row = row;
		};

		// Draw a square at the block's location 
		Block.prototype.drawSquare = function (color) {
			var x = this.col * blockSize;
			var y = this.row * blockSize;
			cxt.fillStyle = color;
			cxt.fillRect(x, y, blockSize, blockSize);
		};

		// Draw a circle at the block's location
		Block.prototype.drawCircle = function (color) {
			var centerX = this.col * blockSize + blockSize / 2;
			var centerY = this.row * blockSize + blockSize / 2;
			cxt.fillStyle = color;
			circle(centerX, centerY, blockSize / 2, true);
		};

		// Check if 2 blocks are overlaping
		Block.prototype.equal = function(otherBlock) {
			return this.col === otherBlock.col && this.row === otherBlock.row;
		};

		// The Snake constructor
		var Snake = function () {
			
			this.segments = [
				new Block(7, 5),
				new Block(6, 5),
				new Block(5, 5)
			];

			this.direction = "right";
			this.nextDirection = "right";

		};

		// Draw a square for each segment of the snake's body
		Snake.prototype.draw = function () {
			for (var i = 0; i < this.segments.length; i++) {
				this.segments[i].drawSquare("Blue");
			};
		};

		// The timeout function to hide the walls for a certain period of time
		var timeoutId = 0;

		// Create a new head and add it to the beginning of the snake to move the snake in its current direction
		Snake.prototype.move = function () {
			
			var head = this.segments[0];
			var newHead;

			this.direction = this.nextDirection;

			if (this.direction === "right") {
				newHead = new Block(head.col + 1, head.row);
			} else if (this.direction === "down") {
				newHead = new Block(head.col, head.row + 1);
			} else if (this.direction === "left") {
				newHead = new Block(head.col - 1, head.row);
			} else if (this.direction === "up") {
				newHead = new Block(head.col, head.row - 1);
			};

			if (this.checkCollision(newHead)) {
				gameOver();
				return;
			};

			this.segments.unshift(newHead);

			var appleHit = this.hitApple(newHead);
			if (appleHit >= 0) {
				score++;
				apples[appleHit].move();
			} else if (newHead.equal(noWalls.position)) {
				score++;
				showWalls = false;
				if (timeoutId !== 0) {
					clearTimeout(timeoutId);
				};
				timeoutId = setTimeout(function () {
					showWalls = true;
					timeoutId = 0;
				}, 5000);
				noWalls.move();
			} else {
				var bombHit = this.hitBomb(newHead);
				if (bombHit >= 0) {
					score--;
					if (score < 0) {
						gameOver();
					};
					this.segments.pop();
					this.segments.pop();
					bombs[bombHit].move();
				} else{
					this.segments.pop();
				};
			};

		};

		// Check if the snake has collided with the wall or itself 
		Snake.prototype.checkCollision = function (head) {
			
			var leftCollision = (head.col === 0);
			var topCollision = (head.row === 0);
			var rightCollision = (head.col === widthInBlocks - 1);
			var bottomCollision = (head.row === heightInBlocks - 1);

			if (showWalls) {
				var wallCollision = leftCollision || topCollision || rightCollision || bottomCollision;
			} else {
				var wallCollision = false;
				if (leftCollision) {
					head.col = widthInBlocks - 1;
				} else if (rightCollision) {
					head.col = 0;
				} else if (topCollision) {
					head.row = heightInBlocks - 1;
				} else if (bottomCollision) {
					head.row = 0;
				};
			};

			var selfCollision = false;

			for (var i = 0; i < this.segments.length; i++) {
				if (head.equal(this.segments[i])) {
					selfCollision = true;
				};
			};

			return wallCollision || selfCollision;

		};

		// Check if the snake has colided with a apple
		Snake.prototype.hitApple = function (head) {
			
			var appleHit = -1

			for (var i = 0; i < apples.length; i++) {
				if (head.equal(apples[i].position)) {
					appleHit = i;
				};	
			};

			return appleHit;

		}

		// Check if the snake has colided with a bomb
		Snake.prototype.hitBomb = function (head) {
			
			var bombHit = -1

			for (var i = 0; i < bombs.length; i++) {
				if (head.equal(bombs[i].position)) {
					bombHit = i;
				};	
			};

			return bombHit;

		}

		// Set the snake's next direction based on the keyboard
		Snake.prototype.setDirection = function (newDirection) {
			
			if (this.direction === "up" && newDirection === "down") {
				return;
			} else if (this.direction === "right" && newDirection === "left") {
				return;
			} else if (this.direction === "down" && newDirection === "up") {
				return;
			} else if (this.direction === "left" && newDirection === "right") {
				return;
			};
			
			this.nextDirection = newDirection;
		
		};

		// The Apple constructor
		var Apple = function () {
			this.position = new Block(10, 10);
		};

		// Draw a circle at the apple's position
		Apple.prototype.draw = function () {
			this.position.drawCircle("LimeGreen");
		};

		// Move the apple to a new random location
		Apple.prototype.move = function () {
			var randomCol = Math.floor(Math.random() * (widthInBlocks - 2)) + 1;
			var randomRow = Math.floor(Math.random() * (heightInBlocks - 2)) + 1;
			this.position = new Block(randomCol, randomRow);
		};

		// The Bomb constructor
		var Bomb = function () {
			this.position = new Block(30, 30);
		};

		// Draw a circle at the bomb's position
		Bomb.prototype.draw = function () {
			this.position.drawCircle("Red");
		};

		// Move the bomb to a new random location
		Bomb.prototype.move = function () {
			var randomCol = Math.floor(Math.random() * (widthInBlocks - 2)) + 1;
			var randomRow = Math.floor(Math.random() * (heightInBlocks - 2)) + 1;
			this.position = new Block(randomCol, randomRow);
		};

		// Set the number of apples to 3
		var nApples = 3;  

		// Set the number of bombs to 5
		var nBombs = 5;

		// Make a variable which identifies if the NoWalls power up has been eaten
		var showWalls = true;

		// The noWalls constructor
		var NoWalls = function (x, y) {
			this.position = new Block(x, y);
		};

		// Draw a circle at the noWalls' position 
		NoWalls.prototype.draw = function () {
			this.position.drawCircle("Blue");
		};

		// Move the noWalls to a new random location
		NoWalls.prototype.move = function () {
			var randomCol = Math.floor(Math.random() * (widthInBlocks - 2)) + 1;
			var randomRow = Math.floor(Math.random() * (heightInBlocks - 2)) + 1;
			this.position = new Block(randomCol, randomRow);
		};

		// Create the snake, apple and bomb objects
		var snake = new Snake();
		var apples = [];
		for (var i = 0; i < nApples; i++) {
			apples.push(new Apple());
			apples[i].move();
		};
		var bombs = [];
		for (var i = 0; i < nBombs; i++) {
			bombs.push(new Bomb());
			bombs[i].move();
		};
		var noWalls = new NoWalls();
		noWalls.move();

		// Pass an animation function to setInterval
		var intervalId = setInterval(function () {
			cxt.clearRect(0, 0, width, height);
			drawScore();
			snake.move();
			snake.draw();
			for (var i = 0; i < apples.length; i++) {
				apples[i].draw();
			};
			for (var i = 0; i < bombs.length; i++) {
				bombs[i].draw();
			};
			if (showWalls) {
				noWalls.draw();
			};	
			if (showWalls) {
				drawBorder();
			};
		}, 100);

		// Convert keycodes to directions
		var directions = {
			37: "left",
			38: "up",
			39: "right",
			40: "down"
		};

		// The keydown handler for handling direction key presses
		$("body").keydown(function (event) {
			var newDirection = directions[event.keyCode];
			if (newDirection !== undefined) {
				snake.setDirection(newDirection);
			};
		});

	</script>

</body>

</html>